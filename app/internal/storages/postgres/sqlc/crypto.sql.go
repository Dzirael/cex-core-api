// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: crypto.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createChain = `-- name: CreateChain :exec
INSERT INTO chains (chain_id, name, created_at, updated_at) 
VALUES ($1, $2, NOW(), NOW())
`

func (q *Queries) CreateChain(ctx context.Context, chainID uuid.UUID, name string) error {
	_, err := q.db.Exec(ctx, createChain, chainID, name)
	return err
}

const createToken = `-- name: CreateToken :exec
INSERT INTO tokens (token_id, is_native, name, symbol, decimals, logo_path, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
`

type CreateTokenParams struct {
	TokenID  uuid.UUID `db:"token_id"`
	IsNative bool      `db:"is_native"`
	Name     string    `db:"name"`
	Symbol   string    `db:"symbol"`
	Decimals int32     `db:"decimals"`
	LogoPath *string   `db:"logo_path"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.Exec(ctx, createToken,
		arg.TokenID,
		arg.IsNative,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.LogoPath,
	)
	return err
}

const createTokenChains = `-- name: CreateTokenChains :exec
INSERT INTO token_chains (token_id, chain_id) 
VALUES ($1, $2)
`

func (q *Queries) CreateTokenChains(ctx context.Context, tokenID uuid.UUID, chainID uuid.UUID) error {
	_, err := q.db.Exec(ctx, createTokenChains, tokenID, chainID)
	return err
}

const getChains = `-- name: GetChains :many
SELECT chain_id, name, created_at, updated_at, deleted_at FROM chains
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

func (q *Queries) GetChains(ctx context.Context, offset int32, limit int32) ([]Chain, error) {
	rows, err := q.db.Query(ctx, getChains, offset, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chain{}
	for rows.Next() {
		var i Chain
		if err := rows.Scan(
			&i.ChainID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupportedTokens = `-- name: GetSupportedTokens :many
SELECT t.token_id, t.is_native, t.name, t.symbol, t.decimals, t.logo_path, t.created_at, t.updated_at, t.deleted_at
FROM tokens t
JOIN token_chains tc ON t.token_id = tc.token_id
WHERE 
  ($1::uuid IS NULL OR tc.chain_id = $1) AND
  ($2::boolean IS NULL OR t.is_native = $2) AND
  t.deleted_at IS NULL
ORDER BY t.created_at DESC
LIMIT $4 OFFSET $3
`

type GetSupportedTokensParams struct {
	ChainID  uuid.UUID `db:"chain_id"`
	IsNative bool      `db:"is_native"`
	Offset   int32     `db:"offset"`
	Limit    int32     `db:"limit"`
}

func (q *Queries) GetSupportedTokens(ctx context.Context, arg GetSupportedTokensParams) ([]Token, error) {
	rows, err := q.db.Query(ctx, getSupportedTokens,
		arg.ChainID,
		arg.IsNative,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Token{}
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.TokenID,
			&i.IsNative,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.LogoPath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByID = `-- name: GetTokenByID :one
SELECT token_id, is_native, name, symbol, decimals, logo_path, created_at, updated_at, deleted_at FROM tokens
WHERE token_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTokenByID(ctx context.Context, tokenID uuid.UUID) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenByID, tokenID)
	var i Token
	err := row.Scan(
		&i.TokenID,
		&i.IsNative,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.LogoPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

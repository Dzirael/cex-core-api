// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: accounts.sql

package sqlc

import (
	"context"
	"time"

	"cex-core-api/app/internal/models"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createAccount = `-- name: CreateAccount :exec
INSERT INTO accounts (account_id, user_id, type) VALUES ($1, $2, $3)
`

type CreateAccountParams struct {
	AccountID uuid.UUID          `db:"account_id"`
	UserID    uuid.UUID          `db:"user_id"`
	Type      models.AccountType `db:"type"`
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.Exec(ctx, createAccount, arg.AccountID, arg.UserID, arg.Type)
	return err
}

const createBalanceTransfer = `-- name: CreateBalanceTransfer :exec
INSERT INTO account_balance_changes (change_id, account_id, token_id, type,action, status, amount, sender, recipient)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateBalanceTransferParams struct {
	ChangeID  uuid.UUID           `db:"change_id"`
	AccountID uuid.UUID           `db:"account_id"`
	TokenID   uuid.UUID           `db:"token_id"`
	Type      models.ChangeType   `db:"type"`
	Action    models.ChangeAction `db:"action"`
	Status    models.ChangeStatus `db:"status"`
	Amount    decimal.Decimal     `db:"amount"`
	Sender    string              `db:"sender"`
	Recipient string              `db:"recipient"`
}

func (q *Queries) CreateBalanceTransfer(ctx context.Context, arg CreateBalanceTransferParams) error {
	_, err := q.db.Exec(ctx, createBalanceTransfer,
		arg.ChangeID,
		arg.AccountID,
		arg.TokenID,
		arg.Type,
		arg.Action,
		arg.Status,
		arg.Amount,
		arg.Sender,
		arg.Recipient,
	)
	return err
}

const decreaseAccountBalance = `-- name: DecreaseAccountBalance :one
WITH updated AS (
    UPDATE account_balances
    SET amount = amount - $1,
        updated_at = NOW()
    WHERE account_id = $2
      AND token_id = $3
      AND (amount - locked_amount) >= $1
    RETURNING balance_id, account_id, token_id, amount, locked_amount, created_at, updated_at, deleted_at
)
SELECT EXISTS(SELECT 1 FROM updated) AS success,
       (SELECT balance_id FROM updated LIMIT 1) AS balance_id
`

type DecreaseAccountBalanceParams struct {
	DecreaseAmount decimal.Decimal `db:"decrease_amount"`
	AccountID      uuid.UUID       `db:"account_id"`
	TokenID        uuid.UUID       `db:"token_id"`
}

type DecreaseAccountBalanceRow struct {
	Success   bool      `db:"success"`
	BalanceID uuid.UUID `db:"balance_id"`
}

func (q *Queries) DecreaseAccountBalance(ctx context.Context, arg DecreaseAccountBalanceParams) (DecreaseAccountBalanceRow, error) {
	row := q.db.QueryRow(ctx, decreaseAccountBalance, arg.DecreaseAmount, arg.AccountID, arg.TokenID)
	var i DecreaseAccountBalanceRow
	err := row.Scan(&i.Success, &i.BalanceID)
	return i, err
}

const decreaseAccountLockedBalance = `-- name: DecreaseAccountLockedBalance :exec
UPDATE account_balances
SET locked_amount = locked_amount - $1
WHERE balance_id = $2
`

func (q *Queries) DecreaseAccountLockedBalance(ctx context.Context, amount decimal.Decimal, balanceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, decreaseAccountLockedBalance, amount, balanceID)
	return err
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT account_id, user_id, type, created_at, updated_at, deleted_at FROM accounts
WHERE account_id = $1
`

func (q *Queries) GetAccountByID(ctx context.Context, accountID uuid.UUID) (Account, error) {
	row := q.db.QueryRow(ctx, getAccountByID, accountID)
	var i Account
	err := row.Scan(
		&i.AccountID,
		&i.UserID,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAccountsByUserID = `-- name: GetAccountsByUserID :many
SELECT account_id, user_id, type, created_at, updated_at, deleted_at FROM accounts
WHERE user_id = $1
`

func (q *Queries) GetAccountsByUserID(ctx context.Context, userID uuid.UUID) ([]Account, error) {
	rows, err := q.db.Query(ctx, getAccountsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Account{}
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.AccountID,
			&i.UserID,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceChangeByID = `-- name: GetBalanceChangeByID :one
SELECT change_id, account_id, token_id, type, action, status, amount, sender, recipient, created_at, updated_at, deleted_at FROM account_balance_changes
WHERE change_id = $1
`

func (q *Queries) GetBalanceChangeByID(ctx context.Context, changeID uuid.UUID) (AccountBalanceChange, error) {
	row := q.db.QueryRow(ctx, getBalanceChangeByID, changeID)
	var i AccountBalanceChange
	err := row.Scan(
		&i.ChangeID,
		&i.AccountID,
		&i.TokenID,
		&i.Type,
		&i.Action,
		&i.Status,
		&i.Amount,
		&i.Sender,
		&i.Recipient,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getBalanceChanges = `-- name: GetBalanceChanges :many
SELECT change_id, account_id, token_id, type, action, status, amount, sender, recipient, created_at, updated_at, deleted_at FROM account_balance_changes
WHERE account_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetBalanceChangesParams struct {
	AccountID uuid.UUID `db:"account_id"`
	Offset    int32     `db:"offset"`
	Limit     int32     `db:"limit"`
}

func (q *Queries) GetBalanceChanges(ctx context.Context, arg GetBalanceChangesParams) ([]AccountBalanceChange, error) {
	rows, err := q.db.Query(ctx, getBalanceChanges, arg.AccountID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AccountBalanceChange{}
	for rows.Next() {
		var i AccountBalanceChange
		if err := rows.Scan(
			&i.ChangeID,
			&i.AccountID,
			&i.TokenID,
			&i.Type,
			&i.Action,
			&i.Status,
			&i.Amount,
			&i.Sender,
			&i.Recipient,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenBalanceByAccountID = `-- name: GetTokenBalanceByAccountID :many
SELECT 
    ab.balance_id,
    ab.amount,
    ab.locked_amount,
    ab.created_at,
    ab.updated_at,
    
    t.token_id,
    t.is_native,
    t.name,
    t.symbol,
    t.decimals,
    t.logo_path
FROM account_balances ab
JOIN tokens t ON ab.token_id = t.token_id
WHERE 
    ab.account_id = $1 AND
    ab.deleted_at IS NULL AND
    t.deleted_at IS NULL
ORDER BY t.name ASC
LIMIT $3 OFFSET $2
`

type GetTokenBalanceByAccountIDParams struct {
	AccountID uuid.UUID `db:"account_id"`
	Offset    int32     `db:"offset"`
	Limit     int32     `db:"limit"`
}

type GetTokenBalanceByAccountIDRow struct {
	BalanceID    uuid.UUID       `db:"balance_id"`
	Amount       decimal.Decimal `db:"amount"`
	LockedAmount decimal.Decimal `db:"locked_amount"`
	CreatedAt    time.Time       `db:"created_at"`
	UpdatedAt    time.Time       `db:"updated_at"`
	TokenID      uuid.UUID       `db:"token_id"`
	IsNative     bool            `db:"is_native"`
	Name         string          `db:"name"`
	Symbol       string          `db:"symbol"`
	Decimals     int32           `db:"decimals"`
	LogoPath     *string         `db:"logo_path"`
}

func (q *Queries) GetTokenBalanceByAccountID(ctx context.Context, arg GetTokenBalanceByAccountIDParams) ([]GetTokenBalanceByAccountIDRow, error) {
	rows, err := q.db.Query(ctx, getTokenBalanceByAccountID, arg.AccountID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokenBalanceByAccountIDRow{}
	for rows.Next() {
		var i GetTokenBalanceByAccountIDRow
		if err := rows.Scan(
			&i.BalanceID,
			&i.Amount,
			&i.LockedAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TokenID,
			&i.IsNative,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.LogoPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseAccountBalance = `-- name: IncreaseAccountBalance :one
INSERT INTO account_balances (balance_id, account_id, token_id, amount, locked_amount)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (account_id, token_id) DO UPDATE
SET amount = account_balances.amount + EXCLUDED.amount,
    locked_amount = account_balances.locked_amount + EXCLUDED.locked_amount,
    updated_at = NOW()
RETURNING balance_id
`

type IncreaseAccountBalanceParams struct {
	BalanceID            uuid.UUID       `db:"balance_id"`
	AccountID            uuid.UUID       `db:"account_id"`
	TokenID              uuid.UUID       `db:"token_id"`
	IncreaseAmount       decimal.Decimal `db:"increase_amount"`
	IncreaseLockedAmount decimal.Decimal `db:"increase_locked_amount"`
}

func (q *Queries) IncreaseAccountBalance(ctx context.Context, arg IncreaseAccountBalanceParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, increaseAccountBalance,
		arg.BalanceID,
		arg.AccountID,
		arg.TokenID,
		arg.IncreaseAmount,
		arg.IncreaseLockedAmount,
	)
	var balance_id uuid.UUID
	err := row.Scan(&balance_id)
	return balance_id, err
}

const updateBalanceTransferStatus = `-- name: UpdateBalanceTransferStatus :exec
UPDATE account_balance_changes
SET status = $1
WHERE change_id = $2
`

func (q *Queries) UpdateBalanceTransferStatus(ctx context.Context, status models.ChangeStatus, changeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateBalanceTransferStatus, status, changeID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: market.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createMarket = `-- name: CreateMarket :exec
INSERT INTO markets (
  market_id,
  token_a_id,
  token_b_id,
  is_active,
  min_order_amount,
  started_at
) VALUES (
  $1, $2, $3, $4, $5, $6
)
`

type CreateMarketParams struct {
	MarketID       uuid.UUID       `db:"market_id"`
	TokenAID       uuid.UUID       `db:"token_a_id"`
	TokenBID       uuid.UUID       `db:"token_b_id"`
	IsActive       bool            `db:"is_active"`
	MinOrderAmount decimal.Decimal `db:"min_order_amount"`
	StartedAt      time.Time       `db:"started_at"`
}

func (q *Queries) CreateMarket(ctx context.Context, arg CreateMarketParams) error {
	_, err := q.db.Exec(ctx, createMarket,
		arg.MarketID,
		arg.TokenAID,
		arg.TokenBID,
		arg.IsActive,
		arg.MinOrderAmount,
		arg.StartedAt,
	)
	return err
}

const getMarketByID = `-- name: GetMarketByID :one
SELECT 
  market_id, token_a_id, token_b_id, is_active, min_order_amount, updated_at, created_at, started_at, deleted_at
FROM markets
WHERE market_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMarketByID(ctx context.Context, marketID uuid.UUID) (Market, error) {
	row := q.db.QueryRow(ctx, getMarketByID, marketID)
	var i Market
	err := row.Scan(
		&i.MarketID,
		&i.TokenAID,
		&i.TokenBID,
		&i.IsActive,
		&i.MinOrderAmount,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.StartedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMarketPair = `-- name: GetMarketPair :one
SELECT market_id, token_a_id, token_b_id, is_active, min_order_amount, updated_at, created_at, started_at, deleted_at
FROM markets
WHERE 
  token_a_id = $1 AND token_b_id = $2 AND deleted_at IS NULL
`

func (q *Queries) GetMarketPair(ctx context.Context, tokenAID uuid.UUID, tokenBID uuid.UUID) (Market, error) {
	row := q.db.QueryRow(ctx, getMarketPair, tokenAID, tokenBID)
	var i Market
	err := row.Scan(
		&i.MarketID,
		&i.TokenAID,
		&i.TokenBID,
		&i.IsActive,
		&i.MinOrderAmount,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.StartedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSupportedPairs = `-- name: GetSupportedPairs :many
SELECT 
  m.market_id,
  m.token_a_id,
  ta.name AS token_a_name,
  m.token_b_id,
  tb.name AS token_b_name,
  m.min_order_amount,
  m.started_at,
  m.created_at,
  m.updated_at
FROM markets m
JOIN tokens ta ON m.token_a_id = ta.token_id
JOIN tokens tb ON m.token_b_id = tb.token_id
WHERE 
  m.deleted_at IS NULL
  AND m.is_active = TRUE
ORDER BY m.created_at DESC
LIMIT $2 OFFSET $1
`

type GetSupportedPairsRow struct {
	MarketID       uuid.UUID       `db:"market_id"`
	TokenAID       uuid.UUID       `db:"token_a_id"`
	TokenAName     string          `db:"token_a_name"`
	TokenBID       uuid.UUID       `db:"token_b_id"`
	TokenBName     string          `db:"token_b_name"`
	MinOrderAmount decimal.Decimal `db:"min_order_amount"`
	StartedAt      time.Time       `db:"started_at"`
	CreatedAt      time.Time       `db:"created_at"`
	UpdatedAt      time.Time       `db:"updated_at"`
}

func (q *Queries) GetSupportedPairs(ctx context.Context, offset int32, limit int32) ([]GetSupportedPairsRow, error) {
	rows, err := q.db.Query(ctx, getSupportedPairs, offset, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSupportedPairsRow{}
	for rows.Next() {
		var i GetSupportedPairsRow
		if err := rows.Scan(
			&i.MarketID,
			&i.TokenAID,
			&i.TokenAName,
			&i.TokenBID,
			&i.TokenBName,
			&i.MinOrderAmount,
			&i.StartedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

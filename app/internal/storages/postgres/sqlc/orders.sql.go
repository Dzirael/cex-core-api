// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: orders.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders (
  order_id,
  account_id,
  market_id,
  side,
  type,
  method,
  amount,
  amount_filled,
  status,
  price,
  expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateOrderParams struct {
	OrderID      uuid.UUID       `db:"order_id"`
	AccountID    uuid.UUID       `db:"account_id"`
	MarketID     uuid.UUID       `db:"market_id"`
	Side         OrderSide       `db:"side"`
	Type         OrderType       `db:"type"`
	Method       OrderMethod     `db:"method"`
	Amount       decimal.Decimal `db:"amount"`
	AmountFilled decimal.Decimal `db:"amount_filled"`
	Status       OrderStatus     `db:"status"`
	Price        decimal.Decimal `db:"price"`
	ExpiresAt    time.Time       `db:"expires_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.OrderID,
		arg.AccountID,
		arg.MarketID,
		arg.Side,
		arg.Type,
		arg.Method,
		arg.Amount,
		arg.AmountFilled,
		arg.Status,
		arg.Price,
		arg.ExpiresAt,
	)
	return err
}

const getUserOrderHistory = `-- name: GetUserOrderHistory :many
SELECT 
  order_id, account_id, market_id, side, type, method, amount, amount_filled, status, price, expires_at, completed_at, created_at, updated_at, deleted_at
FROM orders
WHERE 
  (
    status = $1
    OR $1 IS NULL
  ) 
  AND account_id = $2
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type GetUserOrderHistoryParams struct {
	Status    NullOrderStatus `db:"status"`
	AccountID uuid.UUID       `db:"account_id"`
	Offset    int32           `db:"offset"`
	Limit     int32           `db:"limit"`
}

func (q *Queries) GetUserOrderHistory(ctx context.Context, arg GetUserOrderHistoryParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, getUserOrderHistory,
		arg.Status,
		arg.AccountID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.AccountID,
			&i.MarketID,
			&i.Side,
			&i.Type,
			&i.Method,
			&i.Amount,
			&i.AmountFilled,
			&i.Status,
			&i.Price,
			&i.ExpiresAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :exec
UPDATE orders
SET
  amount = COALESCE($1, amount),
  price = COALESCE($2, price),
  updated_at = NOW()
WHERE
  order_id = $3
  AND deleted_at IS NULL
`

type UpdateOrderParams struct {
	Amount  decimal.Decimal `db:"amount"`
	Price   decimal.Decimal `db:"price"`
	OrderID uuid.UUID       `db:"order_id"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.Exec(ctx, updateOrder, arg.Amount, arg.Price, arg.OrderID)
	return err
}
